Sub 从一个指定的文本文件中读取每一行数据_如果某行以孙兴华开头_写入Excel工作表中的单元格()
 Dim i, j
 Open "D:\BaiduSyncdisk\跟着孙兴华学习Excel VBA\课件\14.使用VBA批量操作TXT和Excel文件\孙兴华.txt" For Input As #1
 i = 1
 '代号1这个文件没有到达末尾时
 Do While Not EOF(1)
 '从1号文件中读取一行文本，把这行文本做为一个字符串保存到s变量中
 Line Input #1, j
 '进行判断，以孙兴华开头的写入单元格
 If Left(j, 3) = "孙兴华" Then
 Range("A" & i) = j
 i = i + 1
 End If
 Loop
 Close #1
End Sub


Sub 用户自己选择文件()
    Dim filePath As String
    Dim i As Long
    Dim lineText As String
'    弹出文件选择对话框，用户选择要打开的文本文件。过滤器限定为 .txt 文件
    ' 用户选择文件路径
    filePath = Application.GetOpenFilename("Text Files (*.txt), *.txt")
'如果用户取消了文件选择（返回“False”），则退出宏
    If filePath = "False" Then Exit Sub
'    启用错误处理机制，若发生错误会跳转到 ErrorHandler 标签处。
    On Error GoTo ErrorHandler
'    以只读模式打开用户选择的文本文件，并将文件句柄分配给 #1。
    Open filePath For Input As #1
    i = 1
    ' 读取文件内容
    '    使用 EOF(1) 来判断文件是否读取到末尾。如果未到达末尾，则继续读取
    Do While Not EOF(1)
'        读取文件中的一行文本并存储到 lineText 变量中
        Line Input #1, lineText

        ' 筛选以 "孙兴华" 开头的行
        If Left(lineText, 3) = "孙兴华" Then
'        将符合条件的行写入 Excel 中，从第 i 行开始
            Range("A" & i) = lineText
            i = i + 1
        End If
    Loop

    Close #1
'    弹出提示框，告知用户文件处理已完成
    MsgBox "文件内容已处理完成！", vbInformation
    Exit Sub

ErrorHandler:
    MsgBox "文件操作出错，请检查路径或内容格式。", vbExclamation
    Close #1
End Sub


'这段代码会遍历工作簿中的所有工作表，对于每张工作表，从第 2 行开始读取 A 列和 B 列的数据
'并将每一行的数据（A 列和 B 列的内容以逗号分隔）写入指定的文本文件 李小龙.txt

Sub 多张工作表同时写入一个文件()
Dim i, s1
Open "D:\BaiduSyncdisk\跟着孙兴华学习Excel VBA\课件\14.使用VBA批量操作TXT和Excel文件\李小龙.txt" For Output As #1
For Each s1 In Sheets
 '每张工作表从第2行开始扫描每一行
 i = 2
 Do While s1.Range("A" & i) <> ""
 Print #1, s1.Range("A" & i); ","; s1.Range("B" & i)
 i = i + 1
 Loop
Next
Close #1
End Sub



'这段代码首先从 姓名.txt 和 功夫.txt 两个文本文件中读取内容，并依次将每行内容写入 Excel 的 A 列。
'然后，将 Excel 中 A 列的内容写入一个新的文本文件 合并.txt。
'最后，关闭所有文件。

Sub 多文件的读取与写入()
Dim i
Open "C:\Users\孙艺航\Desktop\多文件打开写入\姓名.txt" For Input As #1
Open "C:\Users\孙艺航\Desktop\多文件打开写入\功夫.txt" For Input As #2
i = 1
Do While Not EOF(1) Or Not EOF(2)
' 如果文件 1 (#1) 尚未读取完毕
 If Not EOF(1) Then
 Line Input #1, s
 Range("A" & i) = s
 i = i + 1
 End If
' 如果文件 2 (#2) 尚未读取完毕
 If Not EOF(2) Then
 Line Input #2, s
 Range("A" & i) = s
 i = i + 1
 End If
Loop
Close #1: Close #2
Open "C:\Users\孙艺航\Desktop\多文件打开写入\合并.txt" For Output As #3
i = 1
Do While Range("A" & i) <> ""
'将 A 列中的当前行内容写入 合并.txt 文件
 Print #3, Range("A" & i)
 i = i + 1
Loop
'关闭新创建的文本文件 合并.txt
Close #3
End Sub


Sub 遍历所有txt文件()
Dim 文件
'运行Dir函数得到第1个文件的名字
文件 = Dir("C:\Users\孙艺航\Desktop\多文件打开写入\")
'如果读到的文件不是空字符串，就证明这是一个有效文件
Do While 文件 <> ""
 '这里可以对文件进行打开和读取操作
 文件 = Dir '再次运行Dir就读到下一个文件名
Loop
End Sub

'目的是批量读取一个文件夹中的多个 .txt 文件，并将每个文件的内容按行读取，分割并写入到 Excel 工作表中
'每个文件的内容会写入一个新的工作表，并且每个工作表的名称会使用文件名（不包含路径部分）

Sub 批量读取一个文件夹中的多个txt文件()
Dim 文件
'运行Dir函数得到第1个文件的名字
文件 = Dir("C:\Users\孙艺航\Desktop\txt\")
'如果读到的文件不是空字符串，就证明这是一个有效文件
Do While 文件 <> ""
 '这里可以对文件进行打开和读取操作
 Call 读取多个txt文件("C:\Users\孙艺航\Desktop\txt\" & 文件)
 文件 = Dir '再次运行Dir就读到下一个文件名
Loop
End Sub
'读取【带路径的文件名】变量中存储的文件
'取出每行国家名称和确诊人数，写入工作表
Sub 读取多个txt文件(带路径的文件名)
Dim i, w1, x
Set w1 = Worksheets.Add
'设置新工作表的名称为文件名（不包含路径）
'InStrRev 函数用于查找文件路径中的最后一个反斜杠（\）
'然后使用 Mid 函数提取文件名部分
w1.Name = Mid(带路径的文件名, InStrRev(带路径的文件名, "\") + 1)
Open 带路径的文件名 For Input As #1
i = 1
Do While Not EOF(1)
 Line Input #1, x
w1.Range("A" & i) = Split(x, ",")(0)
 w1.Range("B" & i) = Split(x, ",")(1)
 w1.Range("C" & i) = Split(x, ",")(2)
 i = i + 1
Loop
Close #1
End Sub


遍历指定文件夹下的所有 Excel 文件，并逐一打开、处理后关闭每个文件

Sub 遍历文件夹下Excel文件()
Dim w1
文件 = Dir("C:\Users\孙艺航\Desktop\excel\")
Do While 文件 <> ""
'使用 Workbooks.Open 方法打开当前文件，并将其引用赋值给变量 w1
 Set w1 = Workbooks.Open("C:\Users\孙艺航\Desktop\excel\" & 文件)
 '此处可以处理当前打开的工作簿
 
 w1.Close
 文件 = Dir
Loop
End Sub


遍历指定文件夹下的所有 Excel 文件，并将每个文件中第一个工作表复制到当前运行代码的工作簿中，同时将复制的工作表重命名为源文件的文件名（不包括后缀）

Sub 遍历文件夹下Excel文件()
'暂时关闭屏幕更新
Excel.Application.ScreenUpdating = False
Dim w1
文件 = Dir("C:\Users\孙艺航\Desktop\excel\")
Do While 文件 <> ""
 Set w1 = Workbooks.Open("C:\Users\孙艺航\Desktop\excel\" & 文件)
 '打开文件并复制第1张表，放在我这个写代码的工作簿里，有几张表就在表后面粘贴
 w1.Sheets(1).Copy after:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)
 '刚复制的这张表的表名就是w1那个变量的文件名（不要后缀）
'使用 Split 函数按点分割文件名，并提取分割后的第一个部分（即文件名的主干部分）
 ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count).Name = Split(w1.Name, ".")(0)
 w1.Close
 文件 = Dir
Loop
Excel.Application.ScreenUpdating = True
End Sub


遍历指定文件夹中的所有 Excel 文件，并将每个文件的所有工作表复制到当前运行代码的工作簿中。复制的每个工作表都会被重新命名，格式为：文件名.工作表名
Excel 工作表名称最大长度为 31 个字符。如果 文件名.工作表名 超过 31 个字符，代码会报错。

Sub 遍历文件夹下Excel文件()
Excel.Application.ScreenUpdating = False
Dim w1
文件 = Dir("C:\Users\孙艺航\Desktop\多表excel\")
Do While 文件 <> ""
 Set w1 = Workbooks.Open("C:\Users\孙艺航\Desktop\多表excel\" & 文件)
 For Each s1 In w1.Sheets
 '复制s1放到工作表最后面
 s1.Copy after:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)
 '刚复制的这张表的表名就是w1那个变量的文件名（不要后缀）
 ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count).Name = Split(w1.Name, ".")(0) & "." & s1.Name
 Next
 w1.Close
 文件 = Dir
Loop
Sheet1.Select
Excel.Application.ScreenUpdating = True
End Sub


遍历指定文件夹下的所有文件，并筛选出以 .xlsx 或 .xls 为扩展名的 Excel 文件，对每个符合条件的文件进行操作

Sub 遍历文件夹下Excel文件()
Dim w1
文件 = Dir("C:\Users\孙艺航\Desktop\excel\")
Do While 文件 <> ""
 'LCase判断是否以xlsx或xls结尾的文件，英文要考虑大小写一致
'LCase(...)：将字符转换为小写，确保文件扩展名判断不受大小写影响
 If LCase(Right(文件, 5)) = ".xlsx" Or LCase(Right(文件, 4)) = ".xls" Then
 Set w1 = Workbooks.Open("C:\Users\孙艺航\Desktop\excel" & 文件)
 '此处可以处理当前打开的工作簿
 
 w1.Close
 End If
 文件 = Dir
Loop
End Sub


目的是逐行扫描某一列，直到找到空白单元格或达到工作表最大行数为止

Sub 遍历行找到工作表最大行数或空白单元格()
    Dim i As Long
    i = 2 ' 从第二行开始
    Do While Range("A" & i) <> "" And i < ActiveSheet.Rows.Count '确保 i 不会超过当前工作表的最大行数（通常为 1,048,576）
        ' 在这里添加需要对每行执行的操作
        Debug.Print "第" & i & "行的值是：" & Range("A" & i).Value
        i = i + 1 ' 增加行号，避免死循环
    Loop
    MsgBox "遍历完成！共扫描到第" & (i - 1) & "行。", vbInformation
End Sub


确定当前工作表中最后一行的行号，并通过消息框显示出来

Sub 确定表格最后一行通过消息框表示()
 Dim r1, i
 '当前工作表所使用的区域
'返回当前活动工作表中实际使用的单元格区域（包括所有非空单元格）
 Set r1 = ActiveSheet.UsedRange
 'Row从第几行开始+总计多少行-1就得到最后一行的位置了
 i = r1.Row + r1.Rows.Count - 1
 MsgBox "最后一行是" & i
End Sub




Sub 在当前工作表中将某列的所有行填充为一个固定值()
Dim i, r1
'返回当前活动工作表的已使用区域（包含所有非空单元格）
Set r1 = ActiveSheet.UsedRange
For i = 1 To r1.Row + r1.Rows.Count - 1
 Range("G" & i) = 520
Next
End Sub


Sub 在当前工作表中将某列的所有行填充为一个固定值()
    Dim i As Long
    Dim r1 As Range

    ' 获取当前使用区域
'如果工作表中只有一个单元格被“使用”，可能是空白的
'检查使用区域的第一个单元格是否为空
    If ActiveSheet.UsedRange.Cells.Count = 1 And IsEmpty(ActiveSheet.UsedRange.Cells(1)) Then
        MsgBox "当前工作表为空！", vbExclamation
        Exit Sub
    End If

    Set r1 = ActiveSheet.UsedRange

    ' 从使用区域的起始行到最后一行
    For i = r1.Row To r1.Row + r1.Rows.Count - 1
        Range("G" & i) = 520
    Next

    MsgBox "填充完成！", vbInformation
End Sub


数组来操作 Excel 工作表的整个 A 列
数据加载：从 Excel 的 A 列读取有数据的范围（如 A1:A100），加载到数组 arr
数组操作：遍历 arr，将数组中的每个值改为 1。
数据回写：将修改后的 arr 写回 Excel 的 A 列对应范围

Sub 配合数组使用优化()
    Dim arr As Variant, i As Long
    Dim lastRow As Long
    ' 找到 A 列最后一个非空单元格的行号
    lastRow = Range("A" & Rows.Count).End(xlUp).Row
    ' 加载有数据的部分到数组
    arr = Range("A1:A" & lastRow).Value
    ' 遍历数组并修改数据
    For i = 1 To UBound(arr, 1)
        arr(i, 1) = 1
    Next
    ' 写回修改后的数据
    Range("A1:A" & lastRow).Value = arr
    MsgBox "已经完成"
End Sub


定义源工作表和目标工作表（Sheet1 和 Sheet2）
使用 .CurrentRegion 动态获取以 B2 为起始点的连续区域
清空目标工作表中的所有内容，避免残留数据干扰
将源区域的数据复制到目标工作表中，从 A1 单元格开始粘贴
弹出提示框，告知用户操作完成

Sub 单元格拷贝()
    Dim wsSource As Worksheet
    Dim wsTarget As Worksheet
    Dim sourceRange As Range
    Dim targetCell As Range

    ' 定义源工作表和目标工作表
    Set wsSource = ThisWorkbook.Sheets("Sheet1")
    Set wsTarget = ThisWorkbook.Sheets("Sheet2")

    ' 找到源数据范围
    Set sourceRange = wsSource.Range("B2").CurrentRegion

    ' 定义目标单元格
    Set targetCell = wsTarget.Range("A1")

    ' 清空目标工作表中的区域
    wsTarget.Cells.Clear

    ' 将数据从源复制到目标
    sourceRange.Copy targetCell

    MsgBox "数据已成功复制！", vbInformation
End Sub


Sub 单元格拷贝改进()
    Dim targetSheet As Worksheet
    Dim sourceRange As Range
    Dim targetCell As Range

    ' 设置源范围和目标位置
'获取从 B2 开始的连续区域（即包含数据的矩形区域）
    Set sourceRange = Range("B2").CurrentRegion
'代码在执行过程中出错（例如 Sheet2 不存在），程序不会停止，而是继续执行下一行代码
    On Error Resume Next
'尝试设置目标工作表为当前工作簿
    Set targetSheet = ThisWorkbook.Sheets("Sheet2")
'关闭错误忽略模式，恢复默认的错误处理机制
    On Error GoTo 0
'判断 targetSheet 是否成功设置。如果目标工作表不存在，Set 操作失败，targetSheet 会被设置为 Nothing
    If targetSheet Is Nothing Then
        MsgBox "目标工作表不存在！", vbExclamation
        Exit Sub
    End If
    Set targetCell = targetSheet.Range("A1")
    
    ' 复制并粘贴
    sourceRange.Copy
    With targetCell
'确保列宽与源数据保持一致
        .PasteSpecial xlPasteColumnWidths
'粘贴源区域的全部内容，包括格式、公式、值
        .PasteSpecial xlPasteAll
    End With
    
    ' 清除复制模式
    Application.CutCopyMode = False
    MsgBox "数据复制完成！", vbInformation
End Sub


计算并显示两个选定区域的交集区域

'用于返回两个范围的交集
Sub Intersect交叉区域(r1 As Range, r2 As Range)
    Dim 单元格对象 As Range
    On Error Resume Next
    Set 单元格对象 = Excel.Application.Intersect(r1, r2)
    On Error GoTo 0
    If 单元格对象 Is Nothing Then
        MsgBox "不存在交叉区域", vbExclamation
    Else
        MsgBox "交叉区域地址为：" & 单元格对象.Address, vbInformation
    End If
    Set 单元格对象 = Nothing
End Sub

Sub 调用()
    Dim r1 As Range, r2 As Range
    On Error Resume Next
    Set r1 = Application.InputBox("请选择第一个区域：", Type:=8)
    Set r2 = Application.InputBox("请选择第二个区域：", Type:=8)
    On Error GoTo 0
    If r1 Is Nothing Or r2 Is Nothing Then
        MsgBox "未选择有效区域！", vbExclamation
        Exit Sub
    End If
    Call Intersect交叉区域(r1, r2)
End Sub


Sub 多选单元格()
    ' 声明变量
    Dim r1 As Range, r2 As Range
    Dim ws As Worksheet

    ' 指定工作表（可以修改为目标工作表）
    Set ws = ThisWorkbook.Worksheets(1)
    
    ' 遍历指定区域
    For Each r1 In ws.Range("A1:G7")
        If r1.Value = "孙兴华" Then
            ' 如果r2为空，初始化r2
            If r2 Is Nothing Then
                Set r2 = r1
            Else
                ' 合并新的单元格到r2
                Set r2 = Union(r2, r1)
            End If
        End If
    Next r1

    ' 如果找到符合条件的单元格
    If Not r2 Is Nothing Then
        r2.Interior.Color = vbRed ' 设置背景色为红色
        r2.Select ' 选中单元格区域
    Else
        MsgBox "未找到符合条件的单元格！", vbExclamation
    End If

    ' 清理对象
    Set r1 = Nothing
    Set r2 = Nothing
    Set ws = Nothing
End Sub


Sub 添加边框()
 Dim r1 As Range
 Set r1 = Range("A1:G7")
 With r1.Borders
 '边框线条样式
 .LineStyle = xlContinuous
 '边框线条粗细
 .Weight = xlThin
 '边框线条颜色
 .ColorIndex = 5
 End With
 '使用BorderAround方法为单元格区域添加一个加粗外框
 r1.BorderAround xlContinuous, xlMedium, 5
 Set r1 = Nothing
End Sub


在指定的单元格区域 A1:G7 中，设置内部边框为实线和虚线的组合，同时为整个区域添加一个加粗外框

Sub 外实内虚()
 Dim r1 As Range
 Set r1 = Range("A1:G7")
 With r1.Borders(xlInsideHorizontal) ‘内部水平
 .LineStyle = xlDot
 .Weight = xlThin
 .ColorIndex = 5
 End With
 With r1.Borders(xlInsideVertical) ‘内部垂直
 .LineStyle = xlContinuous
 .Weight = xlThin
 .ColorIndex = 5
 End With
 r1.BorderAround xlContinuous, xlMedium, 5
 Set r1 = Nothing
End Sub

'一次排序可同时指定多个关键字（Key1 和 Key2）
'每次调用 .Sort 都能处理多个关键字，减少代码运行的次数
With Range("A1")
    .Sort Key1:="英语", order1:=xlDescending, _
          Key2:="语文", order2:=xlDescending, Header:=xlYes
    .Sort Key1:="数学", order1:=xlDescending, _
          Key2:="总成绩", order2:=xlDescending, Header:=xlYes
End With


根据 E2:E6 区域中定义的自定义排序顺序，对指定的表格数据按“部门”列进行排序

Sub SortByLists()
 Dim arr, 序号
 arr = Range("E2:E6")
 '通过AddCustomList方法为数组添加自定义序列
 Excel.Application.AddCustomList arr
 '返回数组在自定义序列中的序列号，保存在序号这个变量中
 序号 = Application.GetCustomListNum(arr)
 '因为OrderCustom从1开始，如果有一行表头我们就要加1
'表格包含标题行，标题不会参与排序
'指定按照自定义排序顺序排列
 Range("A1").Sort Key1:="部门", Order1:=xlAscending, Header:=xlYes, OrderCustom:=序号 + 1
 '使用DeleteCustomList删除新添加的自定义序列
 Application.DeleteCustomList 序号
End Sub


从某张表中筛选出当天生日的人员，并将这些人员的姓名复制到名为 "生日名单" 的工作表中，同时弹出消息框提示

Sub 提醒过生日的人名()
Dim i
i = 2: j = 1
Do While Range("A" & i) <> ""
'检查当前行的列 C 是否是当天的日期, C 中的日期与当天日期的月份和天数相同，则判定为当天生日
 If Month(Range("C" & i)) = Month(Date) And Day(Range("C" & i)) = Day(Date) Then
 MsgBox "今天是" & Range("A" & i) & "的生日"
 Sheets("生日名单").Range("A" & j) = Range("A" & i)
 j = j + 1
 End If
 i = i + 1
Loop
End Sub
